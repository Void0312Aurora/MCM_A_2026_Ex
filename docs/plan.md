* 第1步：定义“最小可用”的连续时间 SOC 模型（ODE）
  * 产出：核心方程 SOC˙(t)=−P(t)/(V(SOC,T) Ceff)**SOC**˙**(**t**)**=**−**P**(**t**)**/**(**V**(**SOC**,**T**)**C**eff****)** 的版本 0；明确状态、输入、参数与边界（关机阈值）。
* 第2步：确定观测量与采样协议（数据支持而非替代）
  * 产出：采样字段清单（SOC%、电压、温度、charge counter、亮度、CPU 频点驻留等）、采样频率（1–5s）、场景切换记录方式、实验场景设计（待机/亮度/CPU负载/导航等）。
* 第3步：实现 ADB 采样与 CSV 记录（可复现）
  * 产出：一键采样脚本，持续抓 `dumpsys battery`、`dumpsys thermalservice`、亮度、`time_in_state` 增量，落盘成时间序列 CSV（便于参数估计与作图）。
* 第4步：把“配置表”转成可用的功耗先验（但不当作实测）
  * 产出：从 power profile overlay 提取 CPU 频点-功耗表，并与 `time_in_state` 对齐，形成 CPU 子系统的“估计能耗解释器”（用于分解 P(t)**P**(**t**)、给参数初值、做敏感性）。
* 第5步：参数估计与验证 + Time-to-Empty（TTE）预测
  * 产出：用少量场景数据估计 Pbase**P**base、屏幕功耗曲线、CPU功耗缩放系数等；对多个使用情景计算/模拟 t∗**t**∗（空电时间），并与观测/合理行为对比。
* 第6步：不确定性与敏感性分析（题目明确要求）
  * 产出：关键参数（容量、内阻/电压模型、屏幕系数、后台基线、温度系数）对 TTE 的影响排序；给出 TTE 置信区间或区间预测，并指出模型何时好/何时差。
* 第7步：把模型结论转成建议（用户行为 + OS 策略）
  * 产出：可操作建议清单（亮度/网络模式/后台策略/高温下行为），并用模型解释“为什么有效、量级多大”；结合你审阅到的 powerhint/白名单策略解释“OS 为什么会那样调度”。
* 第8步：报告结构与交付物（≤25页）
  * 产出：目录骨架、执行摘要要点、模型—参数—验证—局限—扩展的叙事链；附录放脚本与数据来源说明（并准备 AI 使用报告如需要）。
